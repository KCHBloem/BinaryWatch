/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * Ways to save power:
 * 1. low-power (LPR) mode on internal regulator
 *
 *
 *
 *
 *
 *
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "../Drivers/Include/stm32l010x4.h"
#include <stdio.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#define HIGH 1
#define LOW 0
#define RTC_INIT 1

#define GPIOA_OFF (GPIOA->ODR = 0x00)
#define GPIOB_OFF (GPIOB->ODR = 0x00)

#define BUTTON_PRESSED !(GPIOA->IDR & (0x01 << 2))

void SystemClockConfig(void);
void GPIO_Init(void);
void GPIO_State(GPIO_TypeDef *PORT, uint8_t pin, uint8_t state);
void LPUART_Init(void);
void Delay(uint32_t ms);
void RTC_Init(void);
void initInterrupt(void);

typedef struct Time {
  uint8_t HT;
  uint8_t HU;
  uint8_t MNT;
  uint8_t MNU;
  uint8_t ST;
  uint8_t SU;
} Time;

void updateTime(Time time) {
  GPIO_State(GPIOB, 5, (time.HT & 0x01));
  GPIO_State(GPIOB, 6, (time.HT & 0x02));

  GPIO_State(GPIOB, 4, (time.HU & 0x01));
  GPIO_State(GPIOA, 8, (time.HU & 0x02));
  GPIO_State(GPIOA, 0, (time.HU & 0x04));
  GPIO_State(GPIOA, 1, (time.HU & 0x08));

  GPIO_State(GPIOB, 3, (time.MNT & 0x01));
  GPIO_State(GPIOB, 1, (time.MNT & 0x02));
  GPIO_State(GPIOB, 0, (time.MNT & 0x04));

  GPIO_State(GPIOA, 15, (time.MNU & 0x01));
  GPIO_State(GPIOA, 11, (time.MNU & 0x02));
  GPIO_State(GPIOA, 10, (time.MNU & 0x04));
  GPIO_State(GPIOA, 9, (time.MNU & 0x08));
}

uint8_t show = 0;
Time time;
int main(void) {

  SystemClockConfig();
  GPIO_Init();
  //LPUART_Init();
  RTC_Init();
  initInterrupt();
  //printf("Binary Watch V1.0\r\n");

  uint8_t old = 0;

  while (1) {
    time.MNU = ((RTC->TR & 0xF00) >> 8);

    if (old != time.MNU) {
      old = time.MNU;
      time.HT = ((RTC->TR & 0x300000) >> 20);
      time.HU = ((RTC->TR & 0xF0000) >> 16);
      time.MNT = ((RTC->TR & 0x7000) >> 12);
      time.MNU = ((RTC->TR & 0xF00) >> 8);
      //printf("%d:%d:%d\r\n", ((time.HT * 10) + (time.HU)), ((time.MNT * 10) + time.MNU), ((time.ST * 10) + time.SU));
      if (show) {
        updateTime(time);
      }
    }

  }
}

void initInterrupt(void) {
  SYSCFG->EXTICR[2] = 0x00;
  EXTI->IMR |= 0x0004;
  EXTI->RTSR |= 0x0004;
  NVIC_EnableIRQ(EXTI2_3_IRQn);
  NVIC_SetPriority(EXTI2_3_IRQn, 0);
}

void EXTI2_3_IRQHandler() {
  if (show == 1) {
    GPIOA_OFF;
    GPIOB_OFF;
    show = 0;
  } else {
    show = 1;
    updateTime(time);
  }

  EXTI->PR |= 0x0004;
}

void Delay(uint32_t ms) {
  ms *= 1000;
  while (ms--) {
    __NOP();
  }
}

int __io_putchar(int ch) {
  while (!(LPUART1->ISR & (0x01 << 7))) {
  }

// Write the data to the transmit data register
  LPUART1->TDR = ch;

// Wait for the transmission to complete
  while (!(LPUART1->ISR & (0x01 << 6))) {
  }
  return ch;
}

void GPIO_State(GPIO_TypeDef *PORT, uint8_t pin, uint8_t state) {
  if (state) {
    PORT->ODR |= (0x01 << pin);
  } else {
    PORT->ODR &= ~(0x01 << pin);
  }
}

void GPIO_Init(void) {
  RCC->IOPENR |= RCC_IOPENR_IOPAEN; /* Enable GPIO Clock for PORT A */
  RCC->IOPENR |= RCC_IOPENR_IOPBEN; /* Enable GPIO Clock for PORT B */

  GPIOA->MODER = (0x6B55FE85);
  /* State of the pins:
   * A0: Output Mode              |   A8: Output Mode
   * A1: Output Mode              |   A9: Output Mode
   * A2: Input Mode               |   A10: Output Mode
   * A3: Alternate Function Mode  |   A11: Output Mode
   * A4: Alternate Function Mode  |   A12: Reset State
   * A5: Reset State              |   A13: Alternate Function Mode (SWD)
   * A6: Reset State              |   A14: Alternate Function Mode (SWD)
   * A7: Reset State              |   A15: Output Mode
   */

  GPIOA->AFR[0] |= (0x06 << 12); /* AF6 on Pin A3 */
  GPIOA->AFR[0] |= (0x06 << 16); /* AF6 on Pin A4 */

  GPIOB->MODER = (0xFFFFD555);
  /* State of the pins:
   * B0: Output Mode
   * B1: Output Mode
   * B2: Output Mode
   * B3: Output Mode
   * B4: Output Mode
   * B5: Output Mode
   * B6: Output Mode
   * B7: Reset State
   */

}

void LPUART_Init(void) {

  RCC->APB1ENR |= RCC_APB1ENR_PWREN; /* Power Interface Clock Enable */

  RCC->CCIPR |= (0x02 << 10);
  RCC->APB1ENR |= RCC_APB1ENR_LPUART1EN; /* Low Power UART 1 Clock Enable */

  LPUART1->BRR = 0x8A1A; /* Set Baudrate to 115200...       (256 x Fcpu) / 115200 = 0x8AE3*/

  LPUART1->CR1 |= (0x01 << 3); /* Transmitter Enable */
  LPUART1->CR1 |= (0x01 << 0); /* LPUART Enable */
//LPUART1->CR1 |= USART_CR1_UESM;
}

void RTC_Init(void) {

  RCC->APB1ENR |= RCC_APB1ENR_PWREN; /* Power Interface Clock Enable */
  PWR->CR |= PWR_CR_DBP; /* Unlock Access to CSR */
  RCC->CSR |= RCC_CSR_LSEDRV;
  RCC->CSR |= RCC_CSR_LSEON; /* Enable Low Speed Internal Oscillator */
  while ((RCC->CSR & (RCC_CSR_LSERDY)) != (RCC_CSR_LSERDY)) /* Wait for LSI Oscillator to stabilize */
  {
  }
  RCC->CSR |= RCC_CSR_RTCEN; /* Enable RTC */
  RCC->CSR &= ~(0x03 << 16); /* Clear RTC Oscillator Selection */
  RCC->CSR |= RCC_CSR_RTCSEL_LSE; /* Select Low Speed Internal Oscillator as source for RTC */
  RCC->APB1ENR &= ~ RCC_APB1ENR_PWREN; /* Power Interface Clock Disable */

  uint8_t state = 0;
  uint8_t HT = 0, HU = 0, MNT = 0, MNU = 0;
  if (RTC_INIT) {
    state = 5;
    RTC->BKP0R = 0x00173700;
  }
  while (state == 0) {
    if (HT < 2) {
      HT++;
    } else {
      HT = 0;
    }

    GPIO_State(GPIOB, 5, (HT & 0x01));
    GPIO_State(GPIOB, 6, (HT & 0x02));
    Delay(1000);
    if (BUTTON_PRESSED) {
      state = 1;
    }
  }

  while (state == 1) {
    if (HU < 9) {
      HU++;
    } else {
      HU = 0;
    }
    GPIO_State(GPIOB, 4, (HU & 0x01));
    GPIO_State(GPIOA, 8, (HU & 0x02));
    GPIO_State(GPIOA, 0, (HU & 0x04));
    GPIO_State(GPIOA, 1, (HU & 0x08));
    Delay(1000);
    if (BUTTON_PRESSED) {
      state = 2;
    }
  }

  while (state == 2) {
    if (MNT < 6) {
      MNT++;
    } else {
      MNT = 0;
    }

    GPIO_State(GPIOB, 3, (MNT & 0x01));
    GPIO_State(GPIOB, 1, (MNT & 0x02));
    GPIO_State(GPIOB, 0, (MNT & 0x04));
    Delay(1000);
    if (BUTTON_PRESSED) {
      state = 3;
    }
  }

  while (state == 3) {
    if (MNU < 9) {
      MNU++;
    } else {
      MNU = 0;
    }

    GPIO_State(GPIOA, 15, (MNU & 0x01));
    GPIO_State(GPIOA, 11, (MNU & 0x02));
    GPIO_State(GPIOA, 10, (MNU & 0x04));
    GPIO_State(GPIOA, 9, (MNU & 0x08));
    Delay(1000);
    if (BUTTON_PRESSED) {
      state = 0;
    }
    RTC->BKP0R = ((HT << 20) | (HU << 16) | (MNT << 12) | (MNU << 8)); /*  */

  }
  RTC->WPR = 0xCA; /* Unlock write protection on all RTC registers */
  RTC->WPR = 0x53; /* Unlock write protection on all RTC registers */

  RTC->ISR = RTC_ISR_INIT; /* Allow Time to be edited, initialization mode enabled */
  while ((RTC->ISR & (RTC_ISR_INITF)) != (RTC_ISR_INITF)) {
  }
  RTC->PRER = 0x007F00FF; /* Configure Prescaler: RTCCLK / (PREDIV_A + 1) = 32768kHz / 127 + 1 = 256Hz 256Hz / (PREDIV_S + 1) = 256 / 255 + 1 = 1Hz*/
  RTC->TR = RTC->BKP0R; /*  */
  RTC->CR |= RTC_CR_FMT; /* 24-hour time format */
  RTC->CR |= RTC_CR_BYPSHAD;

  RTC->ISR &= ~RTC_ISR_INIT; /* Initialization mode disabled */

  RTC->WPR = 0xFE; /* Lock write protection on all RTC registers */
  RTC->WPR = 0x64; /* Lock write protection on all RTC registers */

  PWR->CR &= ~ PWR_CR_DBP; /* Lock Access to CSR */

}

void SystemClockConfig(void) {
  RCC->CR |= RCC_CR_HSIDIVEN;
  RCC->CR |= RCC_CR_HSION; /* Enable High speed internal oscillator */
  while ((RCC->CR & RCC_CR_HSIRDY) == 0) { /* Wait for HSI to become stable */
  }

  RCC->APB1ENR |= RCC_APB1ENR_PWREN;
  PWR->CR |= PWR_CR_VOS;

  RCC->CFGR &= ~RCC_CFGR_SW; /* Reset System Clock Switch */
  RCC->CFGR |= RCC_CFGR_SW_HSI; /* System Clock Switch set to HSI16 */
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
    ;
  RCC->CFGR |= RCC_CFGR_MCOPRE_DIV16;
  RCC->CFGR |= RCC_CFGR_MCOSEL_HSI; /* Set HSI Oscillator as Microcontroller Clock */
  RCC->APB1ENR &= ~ RCC_APB1ENR_PWREN; /* Power Interface Clock Disable */

}
